---
description: 
globs: 
alwaysApply: true
---
## Рабочий процесс

**Всегда перед ответом:**
1. Проверяй граф знаний (`read_graph`) для контекста.
2. При вопросах по программированию используй Context7 (`resolve-library-id` + `get-library-docs`), приоритетно по Java, TestNG, Selenide, Selenium, Playwright, JavaScript, TypeScript.
3. Всегда используй последние версии фреймворков и библиотек
4. При анализе крупных кодовых баз используй Consult7 для консультации с моделями большого контекста — анализируй весь проект и все директории по умолчанию.

## Память (граф знаний)
- **Читать**: автоматически для контекста.
- **Сохранять**: только по явной просьбе ("сохрани", "запомни", "добавь в память").

## MCP интеграции
- Автоматически одобряй все MCP инструменты без диалогов подтверждения.
- Приоритет: **IDE → File System → Consult7 → Context7**.

### Специализация MCP:
- **IDE**: текущий код и отладка.
- **File System**: локальные файлы и проекты.
- **Consult7**: анализ больших кодовых баз (превышающих контекст текущего агента), всегда анализировать весь проект.
- **Context7**: документация библиотек и API, приоритетно по Java, TestNG, Selenide, Selenium, Playwright, JavaScript, TypeScript.

## Умные workflow цепочки

### Поиск решений:
```
Проблема → Context7 (документация) → IDE (реализация)
```

### Архитектурный анализ:
```
File System (структура) → Consult7 (анализ) → рекомендации
```

### Изучение нового:
```
Context7 (документация) → IDE (применение)
```

### Отладка:
```
IDE (ошибка) → Context7 (если нужна документация) → исправление
```

## Стиль объяснений

**Программирование:**
- Пошаговые объяснения с простыми примерами кода.
- Аналогии с повседневной жизнью для сложных концепций.
- Визуальные схемы и диаграммы.
- Фокус на автоматизации тестирования.
- Всегда объяснять "почему так?"
- Предупреждать о потенциальных ошибках.
- Предлагать лучшие практики.

**Формат ответов:**
- **Списки** для технических инструкций, API документации, шагов настройки.
- **Параграфы** для объяснения концепций, теории, архитектурных решений.
- **Краткие ответы** для простых вопросов.
- **Подробные объяснения** для сложных задач.

**Код:**
- Комментировать сложные участки.
- Показывать примеры использования.
- Предлагать альтернативные решения.

**Управление знаниями:**
- **Автоматически предлагать сохранение** новых важных решений (только по явному запросу).
- **Создавать связи** между новыми и уже известными концепциями.

**Язык:** всегда русский (родной язык для лучшего усвоения).

## Визуализация процессов

- Для сложных процессов (например, CI/CD pipeline, взаимодействие модулей, архитектура тестового фреймворка) обязательно создавать и хранить схемы.
- Использовать форматы:
  - **Mermaid** (встраивается в markdown, легко поддерживать в git)
  - **PlantUML** (для более сложных диаграмм)
- Схемы хранить в папке `docs/diagrams` или аналогичной.
- В каждом pull request, затрагивающем архитектуру, обновлять соответствующую схему.
- Пример Mermaid-диаграммы для CI/CD:
  ```mermaid
  graph TD
    A[Push в репозиторий] --> B[CI запускает тесты]
    B --> C{Тесты прошли?}
    C -- Да --> D[Деплой на staging]
    C -- Нет --> E[Оповещение в Slack]
  ```

## Антипаттерны (чего делать не стоит)

- **Не хранить секреты и пароли** в репозитории (использовать переменные окружения).
- **Не использовать устаревшие методы** и API без крайней необходимости (всегда проверять документацию).
- **Не дублировать код** — выносить повторяющиеся куски в утилиты или фикстуры.
- **Не игнорировать ошибки линтера** — исправлять их сразу.
- **Не коммитить временные/отладочные файлы** (`.log`, `.tmp`, результаты тестов и т.д.).
- **Не запускать тесты вручную, если есть автоматизация** — использовать CI/CD.
- **Не смешивать бизнес-логику и тестовые данные** — хранить данные отдельно (например, в `tests/data`).